{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Gold language","text":"<p>The Gold language is a programmable configuration language. Gold serves as an alternative to other configuration languages, such as JSON, YAML, TOML and others, by providing access to conventional programming language features such as functions, loops, imports and data sharing. By doing this Gold occupies the same niche as languages like Dhall. Gold offers the following features distinct from Dhall:</p> <ul> <li>a more familiar syntax,</li> <li>a less constraining type system, and</li> <li>first class support for functions.</li> </ul> <p>The final point means that functions are valid as output values from Gold programs. This means that conditions which must be expressed in e.g. Github Actions YAML files as text:</p> <pre><code>jobs:\n  production-deploy:\n    if: github.repository == 'octo-org/octo-repo-prod'\n</code></pre> <p>can be written in Gold in a more natural way</p> <pre><code>{\n  jobs: {\n    production-deploy: {\n      if: |github| github.repository == \"octo-org/octo-repo-prod\"\n    }\n  }\n}\n</code></pre> <p>(In Gold, curly braces define objects, that is, string-value mappings, while the pipe character defines a function.) Here, the value of the <code>if</code> field is a true function to be called by the host application, not a string to be interpreted in whichever mini-language applies for this particular key (which is of course a different mini-language from other keys that need similar features.)</p> <p>This feature of first-class functions was integral to the original motivation for creating the Gold language.</p>"},{"location":"whirlwind/","title":"Whirlwind tour","text":""},{"location":"whirlwind/#core-features-of-gold","title":"Core features of Gold","text":"<p>A Gold file consists of an arbitrary number of top-level statements, of which currently there is only one type: imports. These top-level statements are then followed by a single expression. The value of this expression is the value of the file when evaluated.</p> <p>A Gold program cannot affect its environment in any way: it cannot write files to the disk, make network requests, etc. It also cannot (for the moment) read environment variables. The only data available to a Gold program is the data in the file itself, and other files that it imports. As such, the value of a Gold file when evaluated is necessarily fixed and immutable and a faithful representation of the source files: it cannot change if the the source files also don't change.</p> <p>Aside from the top-level import statements, Gold only has expressions - no statements. Furthermore, every Gold value is immutable.</p> <p>Except in very specific circumstances, Gold is whitespace and indentation insensitive. In every case where comma-separated lists are expected, Gold allows an optional trailing comma.</p> <p>Comments are starting with a pound character <code>#</code> and last until the end of the line.</p>"},{"location":"whirlwind/#types","title":"Types","text":"<p>Gold support all the JSON-like types, with the important addition of functions. In addition to this, Gold distinguishes integers and floating-point *numbers.</p> <ul> <li>integers: <code>0</code>, <code>1</code>, <code>-3</code> etc.,</li> <li>floating-point numbers: <code>1.0</code>, <code>3.14</code>, <code>0.2718e-1</code> etc.,</li> <li>strings, which are double-quoted: <code>\"\"</code>, <code>\"Hello World\"</code> etc.,</li> <li>the singleton objects null, true and false,</li> <li>lists of other values,</li> <li>objects (mappings of strings to other values) and</li> <li>functions.</li> </ul>"},{"location":"whirlwind/#lists","title":"Lists","text":"<p>Lists are constructed with square brackets surrounding a comma-separated list of values.</p> <pre><code>[0, 1.0, \"here is a string\"]\n</code></pre> <p>An empty list is just</p> <pre><code>[]\n</code></pre> <p>Use square brackets to index a list and extract its elements</p> <pre><code>[\"a\", \"b\", \"c\"][1]   # =&gt; \"b\"\n</code></pre> <p>In Gold, indexing is zero-based.</p>"},{"location":"whirlwind/#objects","title":"Objects","text":"<p>Objects are constructed with curly brackets surrounding a comma-separated list of key-value pairs. The key and the value are themselves separated by a colon. In most cases it's not necessary to quote the key.</p> <pre><code>{\n    my-key: \"value\",\n    my-other-key: \"some other value\",\n}\n</code></pre> <p>Quoting the key is necessary if it contains a colon, or if it starts with a quotation mark.</p> <pre><code>{\n    \"with-colon:\": true,\n    \"\\\"with-quote\": true,\n}\n</code></pre> <p>An empty object is just</p> <pre><code>{}\n</code></pre> <p>Gold does not currently support objects whose keys are not strings.</p> <p>Use dot-access syntax to access values from an object, in case the key is compatible with Gold syntax:</p> <pre><code>{x: 1}.x   # =&gt; 1\n</code></pre> <p>But this wouldn't work, since the hyphen is interpreted as a minus operator:</p> <pre><code>{some-key: 1}.some-key\n</code></pre> <p>In this case, rely on explicit indexing with square brackets:</p> <pre><code>{some-key: 1}[\"some-key\"]   # =&gt; 1\n</code></pre>"},{"location":"whirlwind/#binding-names","title":"Binding names","text":"<p>To bind values to names, use the let expression:</p> <pre><code>let x = 1\nin 2 + x\n</code></pre> <p>You can bind multiple names at once:</p> <pre><code>let x = 1\nlet y = 2\nin x + y\n</code></pre> <p>After a sequence of bindings and the keyword <code>in</code> follows a single expression in which all names bound previously are valid. The value of this expression becomes the value of the whole let-expression.</p>"},{"location":"whirlwind/#destructuring","title":"Destructuring","text":"<p>In let-expressions (and anywhere else where values are bound to names, see Advanced collections and Functions), Gold support destructuring assingments.</p> <p>You can destructure lists:</p> <pre><code>let [a, b, c] = [1, 2, 3]\nin a + b + c\n</code></pre> <p>and objects:</p> <pre><code>let {a, b, c} = {a: 1, b: 2, c: 3}\nin a + b + c\n</code></pre> <p>Use the <code>as</code> keyword in object destructuring to use a different bound name than the key in the object:</p> <pre><code>let {a as x, b as y, c as z} = {a: 1, b: 2, c: 3}\nin x + y + z\n</code></pre> <p>In both list and object destructuring contexts, you can provide default values if the right hand side lacks the relevant values:</p> <pre><code>let [a, b, c = 3] = [1, 2]\nin a + b + c\n\nlet {a, b, c = 3} = {a: 1, b: 2}\nin a + b + c\n</code></pre> <p>Destructuring a list that is too long is an error:</p> <pre><code>let [a, b, c] = [1, 2, 3, 4]   # Error here!\nin a + b + c\n</code></pre> <p>To explicitly ignore extraneous values, slurp them by using the ellipsis operator:</p> <pre><code>let [a, b, c, ...] = [1, 2, 3, 4]\nin a + b + c\n</code></pre> <p>or, if the extraneous values are important, bind them to a name too. This will produce a list called <code>rest</code>:</p> <pre><code>let [a, b, c, ...rest] = [1, 2, 3, 4]\nin a + b + c + rest[0]\n</code></pre> <p>You can also collect extraneous key-value pairs in an object:</p> <pre><code>let {a, b, ...rest} = {a: 1, b: 2, c: 3, d: 4}\nin a + b + rest.c + rest.d\n</code></pre> <p>Note that destructuring an object with too many keys is not an error, so there is no need to do something like this:</p> <pre><code>let {a, b, ...} = {a: 1, b: 2, c: 3}\nin a + b\n</code></pre> <p>And, in fact, that syntax is not valid. Instead, his will work just fine:</p> <pre><code>let {a, b} = {a: 1, b: 2, c: 3}\nin a + b\n</code></pre> <p>You can also perform destructuring several levels deep. This pattern, for example, will extract the key <code>c: 1</code> inside a list in an object in a list in an object:</p> <pre><code>let {a as [{b as [{c}]}]} = {a: [{b: [{c: 1}]}]}\nin a\n</code></pre>"},{"location":"whirlwind/#branching","title":"Branching","text":"<p>Gold has a single branching expression:</p> <pre><code>if condition then expression else expression\n</code></pre> <p>Since this is an expression (like everything else in Gold), the else branch is not optional.</p> <p>The value of condition can be anything - not just true or false. For the purposes of branching, everything is considered true except</p> <ul> <li>false</li> <li>null</li> <li>the integer <code>0</code> and the floating-point value <code>0.0</code></li> </ul> <p>Notably, empty lists and objects are considered truthy.</p>"},{"location":"whirlwind/#advanced-collections","title":"Advanced collections","text":"<p>Gold supports a number of features for easily performing advanced logic when constructing collections (lists and objects). This is useful because, Gold objects being immutable, it's not possible to initialize e.g. and empty list and then fill it later, which you might do in Python:</p> <pre><code>mylist = []\n# fill mylist with elements\n</code></pre> <p>First, it's possible to conditionally add elements:</p> <pre><code>[\n    1,\n    if condition: 2,\n    3,\n]\n</code></pre> <p>This may evaluate to <code>[1, 2, 3]</code> or <code>[1, 3]</code> depending on whether the condition is satisfed. Note that this is very different from the following:</p> <pre><code>[\n    1,\n    if condition 2 else null,\n    3,\n]\n</code></pre> <p>which is a list that always contains three elements: either <code>[1, 2, 3]</code> or <code>[1, null, 3]</code>.</p> <p>It's also possible to loop over an existing collection to add its elements to a new collection:</p> <pre><code>let numbers = [3, 4]\nin [\n    1,\n    2,\n    for n in numbers: n,\n    5,\n]\n</code></pre> <p>which evaluates to <code>[1, 2, 3, 4, 5]</code>. For this usage, the following usage of the splicing operator <code>...</code> is equivalent, and probably preferred:</p> <pre><code>let numbers = [3, 4]\nin [1, 2, ...numbers, 5]\n</code></pre> <p>But the <code>for x in y</code> syntax has two important advantages. First, it is possible to perform destructuring:</p> <pre><code>let numbers = [[3], [4]]\nin [\n    1,\n    2,\n    for [n] in numbers: n,\n    5,\n]\n</code></pre> <p>Second, the value produced may be any expression, so that this will also work:</p> <pre><code>let numbers = [[3], [4]]\nin [\n    1,\n    2,\n    for n in numbers: n[0],\n    5,\n]\n</code></pre> <p>And, indeed, loops and conditions may be nested arbitrarily deep:</p> <pre><code># Extract the names of all adults\nlet people = [\n    {name: \"Bob\", age: 42},\n    {name: \"Eve\", age: 24},\n    {name: \"Jill\", age: 12},\n    {name: \"Adam\", age: 15},\n    {name: \"Patricia\", age: 72},\n]\nin [\n    for {name, age} in people:\n        if age &gt; 18: name\n]\n</code></pre> <p>All the above works equally well with objects as with lists, with one important caveat. Consider the following modification of the above code to filter a list of people to obtain a list of adults.</p> <pre><code># Extract ages of all adults\n# ...\nin {\n    for {name, age} in people:\n        if age &gt; 18:\n            name: age\n}\n</code></pre> <p>We only needed to use curly braces instead of square ones, and change <code>name</code> into <code>name: age</code> for the result to be a valid object. However, this will not work as expected. The reason is that in an object, <code>{name: age}</code> interprets <code>name</code> as the literal key, not a bound name to look up.</p> <p>This can be fixed using string interpolation:</p> <pre><code># ...\nin {\n    for {name, age} in people:\n        if age &gt; 18:\n            \"$name\": age\n}\n</code></pre> <p>However, this particular use-case is common enough that Gold supports the alternative syntax <code>$key: value</code></p> <pre><code># ...\nin {\n    for {name, age} in people:\n        if age &gt; 18:\n            $name: age\n}\n</code></pre>"},{"location":"whirlwind/#advanced-strings","title":"Advanced strings","text":"<p>Gold supports string interpolation of other values:</p> <pre><code>let a = \"Gold\"\nin \"This language is $a\"\n</code></pre> <p>To explicitly demarcate the expression to be interpolated, use curly braces. This allows usages like the following, to prevent Gold looking for the binding <code>prefixflammable</code>:</p> <pre><code>let prefix = \"in\"\nin \"Be careful with ${prefix}flammable objects\"\n</code></pre> <p>and the following, where the expression to be interpolated is more sophisticated than just a name:</p> <pre><code>\"1 + 2 is ${1 + 2}\"\n</code></pre> <p>Gold does not currently support format specifiers in string interpolation.</p> <p>To facilitate long strings, Gold supports juxtaposition:</p> <pre><code>\"here\\n\"\n\"is\\a\"\n\"multiline\\n\"\n\"string\\n\"\n</code></pre> <p>Note that the newlines must still be explicitly provided: juxtaposition is just concatenation - no extra characters are added between each part.</p> <p>To facilitate writing objects with string values, which is common in many configuration files, Gold provides the following long-form string syntax:</p> <pre><code>{\n    key:: Some text goes here\n    normal-key: false,\n}\n</code></pre> <p>After a double colon, the string is read from the first non-whitespace character until the end of the last line that precedes a line that is indented not more than the line where the string started. In this example, that line is the third line with the closing brace, which means that the string just contains the text <code>\"Some text goes here\"</code>.</p> <p>Note that there is no comma after such a string before the next element of the object. If there were, it would be treated as part of the string, not a syntactical element.</p> <p>You can use this to create multiline strings too:</p> <pre><code>{\n    key:: This is the first line,\n        this is the second line,\n        and this is the third line.\n    other-key: true,\n}\n</code></pre> <p>From the second line forward, the greatest common indentation is stripped from all lines. Thus the string above could also be rendered as</p> <pre><code>\"This is the first line,\\nthis is the second line,\\nand this is the third line.\"\n</code></pre> <p>If the first line is empty, it is ignored. Extra indentation is not stripped:</p> <pre><code>{\n    example::\n        # This is a faithful representation of Python code with indentation\n        def func(x, y):\n            return x + y\n        print(func(1, 2))\n}\n</code></pre>"},{"location":"whirlwind/#functions","title":"Functions","text":"<p>Functions are defined using the syntax</p> <pre><code>|param1, parm2, ...| expression\n</code></pre> <p>Where expression may depend on the values of param1, param2, etc.</p> <p>Functions in Gold are always anonymous, and must be called immediately or bound to a name to have an effect. For example:</p> <pre><code>let add = |x, y| x + y\nin add(1, 2)\n</code></pre> <p>or</p> <pre><code>(|x, y| x + y)(1, 2)\n</code></pre> <p>Functions may take any number of parameters (including none at all), and form closures around non-local names. For example:</p> <pre><code>let make_adder = |x| |y| x + y\nlet adder = make_adder(3)\nlet x = 4\nin adder(5)\n</code></pre> <p>The <code>make_adder</code> function is a function that returns a function. The value of x referred to by the function adder is enclosed over and is untainted by the later binding of x to 4.</p> <p>Functions may take positional as well as keyword parameters. The two kinds of parameters are separated by a semicolon:</p> <pre><code>|x; y| x + y\n</code></pre> <p>This function can be called in this way:</p> <pre><code>let add = |x; y| x + y\nin add(1, y: 2)\n</code></pre> <p>but not in either of these ways:</p> <pre><code>add(1, 2)\nadd(x: 1, y: 2)\n</code></pre> <p>In Gold, positional and keyword parameters are strictly distinct.</p> <p>Functions which only accept keyword parameters can be defined with the alternative syntax:</p> <pre><code>{|x, y, z|} x + y + z\n</code></pre> <p>Althouth this is perfectly valid (although somewhat ugly):</p> <pre><code>|; x, y, z| x + y + z\n</code></pre> <p>Function parameters are syntactically equivalent to list and object destructuring expressions, respectively. Anything that works in those contexts also works in function definitions:</p> <pre><code>let sum_first_elements = |[x, ...], [y, ...]| x + y\nin sum_first_elements([1, 2], [3, 4])\n</code></pre> <p>Most notably, default parameter values:</p> <pre><code>|x, y = 2; multiply = false| if multiply then x * y else x + y\n</code></pre>"},{"location":"whirlwind/#importing","title":"Importing","text":"<p>Gold supports importing code and data from other files. The import statement takes a path to a file, which is always relative to the file currently being loaded. Gold then evaluates that file and assigns the resulting value to a name or a destructuring pattern.</p> <p>This can be used to write libraries of functions. If this is the contents of the file <code>mylib.gold</code>:</p> <pre><code>{\n    add: |x, y| x + y,\n}\n</code></pre> <p>The function add can then be used from another file like this:</p> <pre><code>import \"mylib.gold\" as mylib\nmylib.add(1, 2)\n</code></pre> <p>or like this:</p> <pre><code>import \"mylib.gold\" as {add}\nadd(1, 2)\n</code></pre> <p>Of course, there is no requirement that the value of an imported file must be an object. For the single function add, the following would work just as well:</p> <pre><code># mylib.gold\n|x, y| x + y\n\n# Other file\nimport \"mylib.gold\" as add\nadd(1, 2)\n</code></pre> <p>Imports are statements and must be found at the beginning of a file preceding the expression to evaluate. It is not possible to import files mid-evaluation.</p>"}]}