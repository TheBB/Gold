{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Gold language","text":"<p>The Gold language is a programmable configuration language. Gold serves as an alternative to other configuration languages, such as JSON, YAML, TOML and others, by providing access to conventional programming language features such as functions, loops, imports and data sharing. By doing this Gold occupies the same niche as languages like Dhall. Gold offers the following features distinct from Dhall:</p> <ul> <li>a more familiar syntax,</li> <li>a less constraining type system, and</li> <li>first class support for functions.</li> </ul> <p>The final point means that functions are valid as output values from Gold programs. This means that conditions which must be expressed in e.g. Github Actions YAML files as text:</p> <pre><code>jobs:\n  production-deploy:\n    if: github.repository == 'octo-org/octo-repo-prod'\n</code></pre> <p>can be written in Gold in a more natural way</p> <pre><code>{\n  jobs: {\n    production-deploy: {\n      if: fn (github) github.repository == \"octo-org/octo-repo-prod\"\n    }\n  }\n}\n</code></pre> <p>(In Gold, curly braces define objects, that is, string-value mappings, while the pipe character defines a function.) Here, the value of the <code>if</code> field is a true function to be called by the host application, not a string to be interpreted in whichever mini-language applies for this particular key (which is of course a different mini-language from other keys that need similar features.)</p> <p>This feature of first-class functions was integral to the original motivation for creating the Gold language.</p> <p>Please continue to the whirlwind tour of features.</p>"},{"location":"formatting/","title":"String formatting","text":"<p>Gold supports string formatting specifiers, similar to what you see in many other languages, for specifying how a value should be formatted when used in a string interpolation context:</p> <pre><code>\"Here is a number: ${number:.2f}\"\n</code></pre> <p>This will format a number using two digits after the decimal point.</p> <p>The format specifier follows the expression to interpolate and is separated from it by a colon.</p> <pre><code>\"${expr:format}\n</code></pre> <p>The format string adheres to the following syntax, which should be fairly familiar if you have used such features in other languages:</p> <pre><code>[[fill]align][sign]['#']['0'][width][grouping][.precision][type]\n</code></pre>"},{"location":"formatting/#fill-and-align","title":"Fill and align","text":"<p>The alignment <code>align</code>, if present, should be one of the following characters:</p> <ul> <li><code>&lt;</code>: indicates that the value should be left-aligned within its space.</li> <li><code>&gt;</code>: indecates that the value should be right-aligned within its space.</li> <li><code>^</code>: indicates that the value should be centered within its space. In case   there is an odd number of available columns, the value will be shifted one   character to the left.</li> <li><code>=</code>: for numbers, indicates that the sign (if any) should be left-aligned and   that the value should be right-aligned.</li> </ul> <p>The <code>fill</code> character, if present, is used to fill the remaining columns. The default fill is a whitespace.</p> <p>By default, numbers are aligned to the right and text values are aligned to the left.</p> <p>In most cases the fill and align settings are not useful unless <code>width</code> is also specified, since then the value will be formatted using exactly the required amount of space.</p>"},{"location":"formatting/#sign","title":"Sign","text":"<p>For numbers, <code>sign</code> should be one of the following characters:</p> <ul> <li><code>+</code>: indicates that the sign should always be printed, using <code>+</code> for   nonnegative numbers and <code>-</code> for negative ones.</li> <li><code>-</code>: indicates that the sign should only be printed for negative numbers.</li> <li><code></code> (a whitespace): indicates that the sign only be printed for negative   numbers, and that a single whitespace be used in place for plus for   nonnegative numbers.</li> </ul>"},{"location":"formatting/#alternate-form","title":"Alternate form","text":"<p>The presence of <code>#</code> indicates printing in alternate form. For numbers printed in non-decimal form, this will add a <code>0x</code>, <code>0X</code>, <code>0b</code> or <code>0o</code> for hexadecimals (lowercase or uppercase), binary or octal numbers, respectively. This indicator will be placed before the number but after the sign (if present). In case the alignment option <code>=</code> is used, it will also be placed before the fill characters.</p>"},{"location":"formatting/#zero-padding","title":"Zero padding","text":"<p>The presence of <code>0</code> is equivalent to a fill and align specifier of <code>0=</code>. That is, numbers will be zero-padded to the left to fill the available space, after the sign (if any).</p>"},{"location":"formatting/#width","title":"Width","text":"<p>The <code>width</code> specifier should be any nonnegative integer indicating the minimum width that the value should take up. There is no requirement that the value cannot use more space if required.</p>"},{"location":"formatting/#grouping","title":"Grouping","text":"<p>Enable the grouping option to print separators between every third digit (in decimal form) or every fourth digit (in binary, octal or hexadecimal form). The available options are:</p> <ul> <li><code>,</code>: use a comma as separator</li> <li><code>_</code>: use an underscore as separator</li> </ul>"},{"location":"formatting/#precision","title":"Precision","text":"<p>For floating-point numbers, the precision should be a nonnegative integer indicating how many digits after the decimal separator to print.</p>"},{"location":"formatting/#formatting-type","title":"Formatting type","text":"<p>The final character, if present, indicates what type of formatting to use. They are divided into three major families: strings, integers and floating-point numbers. The family used influences how certain types are interpreted:</p> <ul> <li>Strings must be formatted as strings, and cannot be used with numerical format   specifiers.</li> <li>Integers must be formatted as integers or floating-point numbers.</li> <li>Booleans are formatted as strings if possible, then integers or floating-point   numbers if not. When interpreted as numbers, <code>true</code> is 1 and <code>false</code> is 0.</li> <li>Null is interpreted as a string, never as a number.</li> <li>Lists and objects cannot be formatted this way.</li> </ul>"},{"location":"formatting/#formatting-strings","title":"Formatting strings","text":"<p>The only string formatting type is <code>s</code>. This is the default if the value being formatted is a string, a boolean or null.</p>"},{"location":"formatting/#formatting-integers","title":"Formatting integers","text":"<p>The available formatting types are:</p> <ul> <li><code>b</code>: format the number in binary form.</li> <li><code>c</code>: interpret the number as a unicode codepoint and print the respective   character.</li> <li><code>d</code>: format the number in decimal form. This is the default if the value being   formatted is an integer.</li> <li><code>o</code>: format the number in octal form.</li> <li><code>x</code>: format the number in hexadecimal form using lowercase letters a-f.</li> <li><code>X</code>: format the number in hexadecimal form using uppercase letters A-F.</li> </ul>"},{"location":"formatting/#formatting-floating-point-numbers","title":"Formatting floating-point numbers","text":"<p>The available formatting types are:</p> <ul> <li><code>e</code>: format the number in scientific form (mantissa and exponent) using a   lowercase 'e'.</li> <li><code>E</code>: format the number in scientific form (mantissa and exponent) using an   uppercase 'E'.</li> <li><code>f</code>: format the number in fixed-point form, using a number of digits indicated   by the precision specifier (default 6).</li> <li><code>g</code>: format the number using the number of digits required for an unambiguous   representation. This is the default if the value being formatted is a   floating-point number. If the precision is provided, the default is <code>f</code>   instead.</li> <li><code>%</code>: multiply the number by 100 and format as with <code>f</code>, printing a trailing   percentage symbol.</li> </ul>"},{"location":"whirlwind/","title":"Whirlwind tour","text":""},{"location":"whirlwind/#core-features-of-gold","title":"Core features of Gold","text":"<p>A Gold file consists of an arbitrary number of top-level statements, of which currently there is only one type: imports. These top-level statements are then followed by a single expression. The value of this expression is the value of the file when evaluated.</p> <p>A Gold program cannot affect its environment in any way: it cannot write files to the disk, make network requests, etc. It also cannot (for the moment) read environment variables. The only data available to a Gold program is the data in the file itself, and other files that it imports. As such, the value of a Gold file when evaluated is necessarily fixed and immutable and a faithful representation of the source files: it cannot change if the the source files also don't change.</p> <p>Aside from the top-level import statements, Gold only has expressions - no statements. Furthermore, every Gold value is immutable.</p> <p>Except in very specific circumstances, Gold is whitespace and indentation insensitive. In every case where comma-separated lists are expected, Gold allows an optional trailing comma.</p> <p>Comments are starting with a pound character <code>#</code> and last until the end of the line.</p>"},{"location":"whirlwind/#types","title":"Types","text":"<p>Gold support all the JSON-like types, with the important addition of functions. In addition to this, Gold distinguishes integers and floating-point *numbers.</p> <ul> <li>integers: <code>0</code>, <code>1</code>, <code>-3</code> etc.,</li> <li>floating-point numbers: <code>1.0</code>, <code>3.14</code>, <code>0.2718e-1</code> etc.,</li> <li>strings, which are double-quoted: <code>\"\"</code>, <code>\"Hello World\"</code> etc.,</li> <li>the singleton objects null, true and false,</li> <li>lists of other values,</li> <li>objects (mappings of strings to other values) and</li> <li>functions.</li> </ul>"},{"location":"whirlwind/#lists","title":"Lists","text":"<p>Lists are constructed with square brackets surrounding a comma-separated list of values.</p> <pre><code>[0, 1.0, \"here is a string\"]\n</code></pre> <p>An empty list is just</p> <pre><code>[]\n</code></pre> <p>Use square brackets to index a list and extract its elements</p> <pre><code>[\"a\", \"b\", \"c\"][1]   # =&gt; \"b\"\n</code></pre> <p>In Gold, indexing is zero-based.</p>"},{"location":"whirlwind/#objects","title":"Objects","text":"<p>Objects are constructed with curly brackets surrounding a comma-separated list of key-value pairs. The key and the value are themselves separated by a colon. In most cases it's not necessary to quote the key.</p> <pre><code>{\n    my-key: \"value\",\n    my-other-key: \"some other value\",\n}\n</code></pre> <p>Quoting the key is necessary if it contains a colon, or if it starts with a quotation mark.</p> <pre><code>{\n    \"with-colon:\": true,\n    \"\\\"with-quote\": true,\n}\n</code></pre> <p>An empty object is just</p> <pre><code>{}\n</code></pre> <p>Gold does not currently support objects whose keys are not strings.</p> <p>Use dot-access syntax to access values from an object, in case the key is compatible with Gold syntax:</p> <pre><code>{x: 1}.x   # =&gt; 1\n</code></pre> <p>But this wouldn't work, since the hyphen is interpreted as a minus operator:</p> <pre><code>{some-key: 1}.some-key\n</code></pre> <p>In this case, rely on explicit indexing with square brackets:</p> <pre><code>{some-key: 1}[\"some-key\"]   # =&gt; 1\n</code></pre>"},{"location":"whirlwind/#binding-names","title":"Binding names","text":"<p>To bind values to names, use the let expression:</p> <pre><code>let x = 1\nin 2 + x\n</code></pre> <p>You can bind multiple names at once:</p> <pre><code>let x = 1\nlet y = 2\nin x + y\n</code></pre> <p>After a sequence of bindings and the keyword <code>in</code> follows a single expression in which all names bound previously are valid. The value of this expression becomes the value of the whole let-expression.</p>"},{"location":"whirlwind/#destructuring","title":"Destructuring","text":"<p>In let-expressions (and anywhere else where values are bound to names, see Advanced collections and Functions), Gold support destructuring assingments.</p> <p>You can destructure lists:</p> <pre><code>let [a, b, c] = [1, 2, 3]\nin a + b + c\n</code></pre> <p>and objects:</p> <pre><code>let {a, b, c} = {a: 1, b: 2, c: 3}\nin a + b + c\n</code></pre> <p>Use the <code>as</code> keyword in object destructuring to use a different bound name than the key in the object:</p> <pre><code>let {a as x, b as y, c as z} = {a: 1, b: 2, c: 3}\nin x + y + z\n</code></pre> <p>In both list and object destructuring contexts, you can provide default values if the right hand side lacks the relevant values:</p> <pre><code>let [a, b, c = 3] = [1, 2]\nin a + b + c\n\nlet {a, b, c = 3} = {a: 1, b: 2}\nin a + b + c\n</code></pre> <p>Destructuring a list that is too long is an error:</p> <pre><code>let [a, b, c] = [1, 2, 3, 4]   # Error here!\nin a + b + c\n</code></pre> <p>To explicitly ignore extraneous values, slurp them by using the ellipsis operator:</p> <pre><code>let [a, b, c, ...] = [1, 2, 3, 4]\nin a + b + c\n</code></pre> <p>or, if the extraneous values are important, bind them to a name too. This will produce a list called <code>rest</code>:</p> <pre><code>let [a, b, c, ...rest] = [1, 2, 3, 4]\nin a + b + c + rest[0]\n</code></pre> <p>You can also collect extraneous key-value pairs in an object:</p> <pre><code>let {a, b, ...rest} = {a: 1, b: 2, c: 3, d: 4}\nin a + b + rest.c + rest.d\n</code></pre> <p>Note that destructuring an object with too many keys is not an error, so there is no need to do something like this:</p> <pre><code>let {a, b, ...} = {a: 1, b: 2, c: 3}\nin a + b\n</code></pre> <p>And, in fact, that syntax is not valid. Instead, his will work just fine:</p> <pre><code>let {a, b} = {a: 1, b: 2, c: 3}\nin a + b\n</code></pre> <p>You can also perform destructuring several levels deep. This pattern, for example, will extract the key <code>c: 1</code> inside a list in an object in a list in an object:</p> <pre><code>let {a as [{b as [{c}]}]} = {a: [{b: [{c: 1}]}]}\nin a\n</code></pre>"},{"location":"whirlwind/#branching","title":"Branching","text":"<p>Gold has a single branching expression:</p> <pre><code>if condition then expression else expression\n</code></pre> <p>Since this is an expression (like everything else in Gold), the else branch is not optional.</p> <p>The value of condition can be anything - not just true or false. For the purposes of branching, everything is considered true except</p> <ul> <li>false</li> <li>null</li> <li>the integer <code>0</code> and the floating-point value <code>0.0</code></li> </ul> <p>Notably, empty lists and objects are considered truthy.</p>"},{"location":"whirlwind/#advanced-collections","title":"Advanced collections","text":"<p>Gold supports a number of features for easily performing advanced logic when constructing collections (lists and objects). This is useful because, Gold objects being immutable, it's not possible to initialize e.g. and empty list and then fill it later, which you might do in Python:</p> <pre><code>mylist = []\n# fill mylist with elements\n</code></pre> <p>First, it's possible to conditionally add elements:</p> <pre><code>[\n    1,\n    if condition: 2,\n    3,\n]\n</code></pre> <p>This may evaluate to <code>[1, 2, 3]</code> or <code>[1, 3]</code> depending on whether the condition is satisfed. Note that this is very different from the following:</p> <pre><code>[\n    1,\n    if condition 2 else null,\n    3,\n]\n</code></pre> <p>which is a list that always contains three elements: either <code>[1, 2, 3]</code> or <code>[1, null, 3]</code>.</p> <p>It's also possible to loop over an existing collection to add its elements to a new collection:</p> <pre><code>let numbers = [3, 4]\nin [\n    1,\n    2,\n    for n in numbers: n,\n    5,\n]\n</code></pre> <p>which evaluates to <code>[1, 2, 3, 4, 5]</code>. For this usage, the following usage of the splicing operator <code>...</code> is equivalent, and probably preferred:</p> <pre><code>let numbers = [3, 4]\nin [1, 2, ...numbers, 5]\n</code></pre> <p>But the <code>for x in y</code> syntax has two important advantages. First, it is possible to perform destructuring:</p> <pre><code>let numbers = [[3], [4]]\nin [\n    1,\n    2,\n    for [n] in numbers: n,\n    5,\n]\n</code></pre> <p>Second, the value produced may be any expression, so that this will also work:</p> <pre><code>let numbers = [[3], [4]]\nin [\n    1,\n    2,\n    for n in numbers: n[0],\n    5,\n]\n</code></pre> <p>And, indeed, loops and conditions may be nested arbitrarily deep:</p> <pre><code># Extract the names of all adults\nlet people = [\n    {name: \"Bob\", age: 42},\n    {name: \"Eve\", age: 24},\n    {name: \"Jill\", age: 12},\n    {name: \"Adam\", age: 15},\n    {name: \"Patricia\", age: 72},\n]\nin [\n    for {name, age} in people:\n        if age &gt; 18: name\n]\n</code></pre> <p>All the above works equally well with objects as with lists, with one important caveat. Consider the following modification of the above code to filter a list of people to obtain a list of adults.</p> <pre><code># Extract ages of all adults\n# ...\nin {\n    for {name, age} in people:\n        if age &gt; 18:\n            name: age\n}\n</code></pre> <p>We only needed to use curly braces instead of square ones, and change <code>name</code> into <code>name: age</code> for the result to be a valid object. However, this will not work as expected. The reason is that in an object, <code>{name: age}</code> interprets <code>name</code> as the literal key, not a bound name to look up.</p> <p>This can be fixed using string interpolation:</p> <pre><code># ...\nin {\n    for {name, age} in people:\n        if age &gt; 18:\n            \"$name\": age\n}\n</code></pre> <p>However, this particular use-case is common enough that Gold supports the alternative syntax <code>$key: value</code></p> <pre><code># ...\nin {\n    for {name, age} in people:\n        if age &gt; 18:\n            $name: age\n}\n</code></pre>"},{"location":"whirlwind/#advanced-strings","title":"Advanced strings","text":"<p>Gold supports string interpolation of other values:</p> <pre><code>let a = \"Gold\"\nin \"This language is ${a}\"\n</code></pre> <p>The curly braces are mandatory. The expression to be interpolated can of course be more sophisticated than just a name:</p> <pre><code>\"1 + 2 is ${1 + 2}\"\n</code></pre> <p>Gold also supports format specifiers, see string formatting.</p> <p>To facilitate long strings, Gold supports juxtaposition:</p> <pre><code>\"here\\n\"\n\"is\\a\"\n\"multiline\\n\"\n\"string\\n\"\n</code></pre> <p>Note that the newlines must still be explicitly provided: juxtaposition is just concatenation - no extra characters are added between each part.</p> <p>To facilitate writing objects with string values, which is common in many configuration files, Gold provides the following long-form string syntax:</p> <pre><code>{\n    key:: Some text goes here\n    normal-key: false,\n}\n</code></pre> <p>After a double colon, the string is read from the first non-whitespace character until the end of the last line that precedes a line that is indented not more than the line where the string started. In this example, that line is the third line with the closing brace, which means that the string just contains the text <code>\"Some text goes here\"</code>.</p> <p>Note that there is no comma after such a string before the next element of the object. If there were, it would be treated as part of the string, not a syntactical element.</p> <p>You can use this to create multiline strings too:</p> <pre><code>{\n    key:: This is the first line,\n        this is the second line,\n        and this is the third line.\n    other-key: true,\n}\n</code></pre> <p>From the second line forward, the greatest common indentation is stripped from all lines. Thus the string above could also be rendered as</p> <pre><code>\"This is the first line,\\nthis is the second line,\\nand this is the third line.\"\n</code></pre> <p>If the first line is empty, it is ignored. Extra indentation is not stripped:</p> <pre><code>{\n    example::\n        # This is a faithful representation of Python code with indentation\n        def func(x, y):\n            return x + y\n        print(func(1, 2))\n}\n</code></pre>"},{"location":"whirlwind/#functions","title":"Functions","text":"<p>Functions are defined using the syntax</p> <pre><code>fn (param1, parm2, ...) expression\n</code></pre> <p>Where expression may depend on the values of param1, param2, etc.</p> <p>Functions in Gold are always anonymous, and must be called immediately or bound to a name to have an effect. For example:</p> <pre><code>let add = fn (x, y) x + y\nin add(1, 2)\n</code></pre> <p>or</p> <pre><code>(fn (x, y) x + y)(1, 2)\n</code></pre> <p>Functions may take any number of parameters (including none at all), and form closures around non-local names. For example:</p> <pre><code>let make_adder = fn (x) fn (y) x + y\nlet adder = make_adder(3)\nlet x = 4\nin adder(5)\n</code></pre> <p>The <code>make_adder</code> function is a function that returns a function. The value of x referred to by the function adder is enclosed over and is untainted by the later binding of x to 4.</p> <p>Functions may take positional as well as keyword parameters. The two kinds of parameters are separated by a semicolon:</p> <pre><code>fn (x; y) x + y\n</code></pre> <p>This function can be called in this way:</p> <pre><code>let add = fn (x; y) x + y\nin add(1, y: 2)\n</code></pre> <p>but not in either of these ways:</p> <pre><code>add(1, 2)\nadd(x: 1, y: 2)\n</code></pre> <p>In Gold, positional and keyword parameters are strictly distinct.</p> <p>Functions which only accept keyword parameters can be defined with the alternative syntax:</p> <pre><code>fn {x, y, z} x + y + z\n</code></pre> <p>Althouth this is perfectly valid (although somewhat ugly):</p> <pre><code>fn (; x, y, z) x + y + z\n</code></pre> <p>Function parameters are syntactically equivalent to list and object destructuring expressions, respectively. Anything that works in those contexts also works in function definitions:</p> <pre><code>let sum_first_elements = fn ([x, ...], [y, ...]) x + y\nin sum_first_elements([1, 2], [3, 4])\n</code></pre> <p>Most notably, default parameter values:</p> <pre><code>fn (x, y = 2; multiply = false) if multiply then x * y else x + y\n</code></pre>"},{"location":"whirlwind/#importing","title":"Importing","text":"<p>Gold supports importing code and data from other files. The import statement takes a path to a file, which is always relative to the file currently being loaded. Gold then evaluates that file and assigns the resulting value to a name or a destructuring pattern.</p> <p>This can be used to write libraries of functions. If this is the contents of the file <code>mylib.gold</code>:</p> <pre><code>{\n    add: fn (x, y) x + y,\n}\n</code></pre> <p>The function add can then be used from another file like this:</p> <pre><code>import \"mylib.gold\" as mylib\nmylib.add(1, 2)\n</code></pre> <p>or like this:</p> <pre><code>import \"mylib.gold\" as {add}\nadd(1, 2)\n</code></pre> <p>Of course, there is no requirement that the value of an imported file must be an object - only a convention (although a strong one). For the single function add, the following would work just as well:</p> <pre><code># mylib.gold\nfn (x, y) x + y\n\n# Other file\nimport \"mylib.gold\" as add\nadd(1, 2)\n</code></pre> <p>Imports are statements and must be found at the beginning of a file preceding the expression to evaluate. It is not possible to import files mid-evaluation.</p>"}]}